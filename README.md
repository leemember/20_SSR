# 🙂 SSR (서버 사이드 렌더링)

- 서버 사이드 렌더링 : UI를 서버에서 렌더링하는 것을 의미한다.
- 클라이언트 사이드 렌더링 : UI 렌더링을 브라우저에서 모두 처리하는 것 <br>
  ✔ 즉, 자바스크립트를 실행해야 작업자가 만든 화면이 사용자에게 보인다.

## 💫 장점

- 구글, 네이버, 다음 등의 검색 엔진이 우리가 만든 웹 애플리케이션의 페이지를 원활하게 수집해준다.
  ✔ 따라서 웹 서비스의 검색 엔진 최적화를 위해서라면 서버 사이드 렌더링을 구현 해주는 것이 좋다.

- 초기 렌더링 성능을 개선할 수 있다. <br>
  ✔ 예를들면, SSR이 구현되지 않은 웹 페이지에 사용자가 방문하면, JS가 로딩되고 실행될 때 까지 사용자는 비어 있는 페이지를 보며 대기해야한다. 여기에 API까지 호출해야 한다면 사용자의 대기 시간은 더더욱 길어진다. <br><br>
  반면 서버 사이드 렌더링을 구현한 웹 페이지라면 JS 파일 다운로드가 완료되지 않은 시점에서도 HTML상에 사용자가 볼 수 있는 콘텐츠가 있기 때문에 대기 시간이 최소화되고, 이로 인해 사용자 경험도 향상된다.

## 💫 단점

- SSR은 결국 원래 브라우저가 해야 할 일을 서버가 대신 처리하는 것이므로 서버 리소스가 사용된다.
- 수많은 사용자가 동시에 웹 페이지에 접속하면 서버에 과부하가 생김. <BR>
  ✔ 해결방안 : 사용자가 많은 서비스라면 <b>캐싱과 로드 밸런싱</b>을 통해 성능을 최적화 해줘야한다.
- 개발이 어려워 질 수 있다. <br>
  SSR을 하면 프로젝트의 구조가 좀 더 복잡해질 수 있고, <데이터 미리 불러오기 / 코드 스플리팅> 과의 호환 등 고려해야 할 사항이 더 많아지기 때문이다.

<BR>

---

<BR>

## 💫 SSR과 코드 스플리팅 충돌

- SSR과 코드스플리팅을 함께 적용시 작업이 꽤 까다롭다. <BR>
  별도의 호환 작업 없이 두 기술을 함께 적용하면, 페이지에 깜박임이 발생한다.

### 🔵 [충돌 흐름도]

1. 서버 사이드 렌더링된 결과물이 브라우저에 나타난다
2. JS파일 로딩 시작
3. JS 실행되면서 아직 불러오지 않은 컴포넌트를 NULL로 렌더링
4. 페이지에서 코드 스플리팅된 컴포넌트들이 사라짐
5. 코드 스플리팅된 컴포넌트들이 로딩된 이후 제대로 나타남

이런 이슈를 해결하려면 라우트 경로마다 코드 스플리팅된 파일 중에서 필요한 모든 파일을 브라우저에서 렌더링하기 전에 미리 불러와야 한다.

<br>

### 🔵 [해결방안]

- Loadable Components 라이브러리에서 제공하는 기능을 써서 서버 사이드 렌더링 후 필요한 파일의 경로를 추출하여 렌더링 결과에 스크립트/스타일 태그를 삽입해 주는 방법입니다.

<br>

---

<br>

## 💫 프로젝트 시작

<br>

1. 라이브러리 설치하기

```
$npm install react-router-dom
```

2. 컴포넌트 만들기

- components/Red.js ➡ 빨간 상자 컴포넌트
- components/Blue.js ➡ 파란 상자 컴포넌트
- components/Menu.js ➡ 링크로 이동 시켜주는 메뉴 컴포넌트
  <br>
  <br>
  <br>

- pages/RedPage.js
- pages/BluePage.js

<br>


-----
## 💫 서버 사이드 렌더링 구현하기

<br>

### 1. 서버 사이드 렌더링용 엔트리 만들기
엔트리 웹팩에서 프로젝트를 불러올 때 가장 먼저 불러오는 파일이다. 예를 들어 현재 작성 중인 리액트 프로젝트에서는 index.js를 엔트리 파일로 사용한다.

이 파일부터 시작하여 내부에 필요한 다른 컴포넌트와 모듈을 불러오고 있다.

- 프로젝트 전에 라이브러리 설치해야 된다.
npm 프로젝트에서 yarn 설치 후 eject 설치하는 법
```
$npm install -g yarn
$yarn eject
```

<br>

서버 사이드 렌더링을 할 때는 서버를 위한 엔트리 파일을 따로 생성해야한다.

- [src]-[index.server.js]

서버에서 리액트 컴포넌트를 렌더링할 때는 ReactDOMServer의 renderToString이라는 함수를 이용한다. 이 함수에 JSX를 넣어서 호출하면 렌더링 결과를 문자열로 반환해준다.

<br>

### 2. SSR 전용 웹팩 환경 설정 작성하기

config 경로의 paths.js 파일 열어서
module.exports 부분에 코드 두 줄 추가

```
ssrIndexJs:resolveApp('src/index.server.js'), //SSR 엔트리
ssrBuild:resolveApp('dist') //웹팩 처리 후 저장 경로
```
ssrIndexJs, ssrBuild 정보를 추가해준다. 

ssrIndexJs : 불러올 파일의 경로

ssrBuild : 웹팩으로 처리한 뒤 결과물을 저장할 경로

- [config]-[webpack.config.server.js] 생성

(1) 웹팩 기본 설정 할 때, 빌드할 때 어떤 파일에서 시작해 파일들을 불러오는지 또 어떤 결과물을 저장할지 정해준다.

(2) 로더 설정 : 웹팩의 로더는 파일을 불러올 때 확장자에 맞게 필요한 처리를 해준다. 예를들어 자바스크립트는 babel을 사용하여 트랜스파일링을 해주고, CSS는 모든 CSS코드를 결합해주고, 이미지 파일은 다른 경로에 따로 저장하고 그 파일에 대한 경로를 자바스크립트에서 참조할 수 있게 해준다.

### 3. 웹팩 라이브러리 설치

```
$yarn add webpack-node-externals
```

서버를 위해 번들링 할 때는 node_modules에서 불러오는 것을 제외하고 번들링하는 것이 좋다. 이를 위해 위 라이브러리를 사용해야 한다.

설치한 이 라이브러리를 webpack.config.server 상단에 불러와 설정에 적용해준다.

### 4. 빌드 스크립트 작성하기

scripts/build.server.js 코드를 다 작성하고

```
$node scripts/build.server.js
```
이 명령어를 실행하여 빌드가 잘되는지 확인한다.

성공적으로 잘 싱행되면 다음 명령어를 실행하여 작성한 결과물이 잘 작동하는지 확인

```
$node dist/server.js
```

테스트 삼아 만든 JSX가 문자열 형태로 잘 렌더링되면, 매번 빌드하고 실행할 때마다 파일 경로를 입력하는 것이 번거로울 수 있으니, package.json에서 스크립트를 생성하여 더 편하게 명령어를 입력할 수 있도록 한다.

```
"scripts": {
    "start": "node scripts/start.js",
    "build": "node scripts/build.js",
    "test": "node scripts/test.js",
    "start:server": "node dist/server.js",
    "build:server": "node scripts/build.server.js"
  },
```
이렇게 스크립트 부분에다가 "start:server", "build:server"를 추가해주면

```
$yarn build:server
$yarn start:server
```

이렇게만 입력해도 잘 작동하는 것을 볼 수 있다.

### 5. 서버 코드 작성하기

서버 사이드 렌더링을 처리할 서버를 작성한다. Express라는 Node.js 웹 프레임워크를 사용하여 웹 서버를 만든다. 이 과정은 꼭 Express가 아니어도 상관 없다.

😀 Express 대체 방법

- Koa, Hapi, connect 라이브러리 사용시 구현 가능
- Express를 사용하는 이유 : 해당 프레임워크가 사용률이 가장 높고, 추후 정적 파일들을 호스팅할 때도 쉽게 구현할 수 있기 때문이다.

```
$yarn add express
```

express 설치한 후에 [index.server.js] 코드 작성하기

<br>

이 과정에서 리액트 라우터 안에 들어 있는 StaticRouter 라는 컴포넌트가 사용되었다. 이 라우터 컴포넌트는 주로 서버 사이드 렌더링 용도로 사용되는 라우터이다. props로 넣어주는 location 값에 따라 라우팅을 해준다.
지금은 req.url이라는 값을 넣어주었는데 여기서 req객체는 요청에 대한 정보를 지니고 있다.

그러니 url을 요청해달란 뜻임.

StaticRouter에 context라는 props도 넣어주었다. 이 값을 사용하여 나중에 렌더링한 컴포넌트에 따라 HTTP 상태 코드를 설정해 줄 수 있다.